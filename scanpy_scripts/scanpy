#!/usr/bin/env python3

import logging
import re
import click
import numpy as np
import scanpy as sc


inf = float('inf')


option_input_obj_and_format = [
    click.option(
        '--input-format', '-f',
        type=click.Choice(['anndata', 'loom', 'zarr']),
        default='anndata',
        show_default=True,
        help='Input object format',
    ),
    click.argument(
        'input_obj',
        type=click.Path(exists=True, dir_okay=False),
    ),
]

option_output_obj_and_format = [
    click.option(
        '--output-format', '-F',
        type=click.Choice(['anndata', 'loom', 'zarr']),
        default='anndata',
        show_default=True,
        help='Output object format',
    ),
    click.option(
        '--chunk-size', '-z',
        type=click.INT,
        default=1000,
        show_default=True,
        help='Chunk size for writing output in zarr format',
    ),
    click.option(
        '--show-obj',
        type=click.Choice(['stdout', 'stderr']),
        default=None,
        show_default=True,
        help='Print output object summary info to specified stream',
    ),
    click.argument(
        'output_obj',
        type=click.Path(),
    ),
]


def add_options(options):
    def _add_options(func):
        for option in reversed(options):
            func = option(func)
        return func
    return _add_options


def read_obj(input_obj, input_format='anndata'):
    if input_format == 'anndata':
        adata = sc.read(input_obj)
    elif input_format == 'loom':
        adata = sc.read_loom(input_obj)
    elif input_format == 'zarr':
        adata = sc.read_zarr(input_obj)
    else:
        raise NotImplementedError(
            'Unsupported input format: {}'.format(input_format))
    return adata


def write_obj(adata, output_obj, output_format='anndata', chunk_size=1000, show_obj=None):
    if output_format == 'anndata':
        adata.write(output_obj, compression='gzip')
    elif output_format == 'loom':
        adata.write_loom(output_obj)
    elif output_format == 'zarr':
        adata.write_zarr(output_obj, chunk_size)
    else:
        raise NotImplementedError(
            'Unsupported output format: {}'.format(output_format))
    if show_obj:
        click.echo(repr(adata).replace('\xd7', 'x'), err=(show_obj == 'stderr'))
    return 0


class CommaSeparatedText(click.ParamType):
    def __init__(self, dtype=str):
        self.dtype = dtype
        self.dtype_name = dtype.__name__
        self.name = '{}[,{}...]'.format(self.dtype_name, self.dtype_name)

    def convert(self, value, param, ctx):
        try:
            return list(map(self.dtype, value.split(',')))
        except ValueError:
            self.fail('{} is not a valid comma separated list of {}'.format(
                value, self.dtype_name), param, ctx)


@click.group()
@click.option(
    '--debug',
    is_flag=True,
    default=False,
    help='Print debug information',
)
@click.option(
    '--profile',
    is_flag=True,
    default=False,
    help='Print profiling information',
)
@click.version_option(
    version='0.2.0',
    prog_name='scanpy',
)
def cli(debug, profile):
    log_level = logging.DEBUG if debug else logging.INFO
    logging.basicConfig(
        level=log_level,
        format=('%(asctime)s; %(levelname)s; %(filename)s; '
                '%(funcName)s(): %(message)s'),
        datefmt='%y-%m-%d %H:%M:%S',
    )
    logging.debug('debugging')


@click.command('read')
@click.pass_context
@click.option(
    '--input-10x-h5', '-i',
    type=click.Path(exists=True, dir_okay=False),
    help='Input 10x data in hdf5 format, '
    'take priority over --input-10x-mtx when both given.',
)
@click.option(
    '--input-10x-mtx', '-x',
    type=click.Path(exists=True, file_okay=False),
    help='Path of input folder containing 10x data in mtx format.',
)
@add_options(option_output_obj_and_format)
@click.option(
    '--genome', '-g',
    default='hg19',
    show_default=True,
    help='Name of the genome group in hdf5 file, '
    'requested by "--input-10x-h5".',
)
@click.option(
    '--var-names', '-v',
    type=click.Choice(['gene_symbols', 'gene_ids']),
    default='gene_symbols',
    show_default=True,
    help='Attribute to be used as the index of the variable table, '
    'requested by "--input-10x-mtx".',
)
def read_cmd(
        ctx,
        input_10x_h5,
        input_10x_mtx,
        output_obj,
        output_format='anndata',
        chunk_size=1000,
        show_obj=None,
        genome='hg19',
        var_names='gene_symbols',
):
    """Read 10x data and save to an output in specified format.

    \b
    OUTPUT_OBJ: output file in format specfied by --output-format
"""
    if input_10x_h5 is not None:
        adata = sc.read_10x_h5(input_10x_h5, genome=genome)
    elif input_10x_mtx is not None:
        adata = sc.read_10x_mtx(input_10x_mtx, var_names=var_names)
    else:
        ctx.fail('At least one of --input-10x-mtx and --input-10x-h5 '
                 'must be given')

    write_obj(
        adata,
        output_obj,
        output_format=output_format,
        chunk_size=chunk_size,
        show_obj=show_obj,
    )
    return 0


def validate_limit(ctx, param, value):
    if value[0] > value[1]:
        param.type.fail(
            'lower limit must not exceed upper limit', param, ctx)
    return value


def validate_parameter_limits(ctx, param, value):
    for v in value:
        if v[1] > v[2]:
            param.type.fail(
                'lower limit must not exceed upper limit', param, ctx)
    return value


def normalise_dtype(typ):
    remove_digits = str.maketrans('', '', '0123456789')
    return eval(str(typ).translate(remove_digits).replace('object', 'str'))


def get_attributes(adata):
    attributes = {
        'cell': {
            'numerical': [],
            'categorical': ['cell:index'],
            'bool': [],
        },
        'gene': {
            'numerical': [],
            'categorical': ['gene:index'],
            'bool': [],
        },
    }

    for attr, dtype in adata.obs.dtypes.to_dict().items():
        typ = normalise_dtype(dtype)
        if typ is str:
            attributes['cell']['categorical'].append(attr)
        elif typ is int or typ is float:
            attributes['cell']['numerical'].append(attr)
        elif typ is bool:
            attributes['cell']['bool'].append(attr)

    for attr, dtype in adata.var.dtypes.to_dict().items():
        typ = normalise_dtype(dtype)
        if typ is str:
            attributes['gene']['categorical'].append(attr)
        elif typ is int or typ is float:
            attributes['gene']['numerical'].append(attr)
        elif typ is bool:
            attributes['gene']['bool'].append(attr)

    attributes['cell']['numerical'].extend([
        'n_genes',
        'cell:n_counts',
        'pct_counts_in_top_<n>_genes',
    ])

    for attr in attributes['gene']['bool']:
        attributes['cell']['numerical'].append('pct_counts_' + attr)

    attributes['gene']['numerical'].extend([
        'n_cells',
        'gene:n_counts',
        'mean_counts',
        'pct_dropout_by_counts',
    ])
    logging.debug(attributes)
    return attributes


def get_filter_conditions(adata, attributes, param, category, subset):
    conditions = {
        'cell': {
            'numerical': [],
            'categorical': [],
            'bool': [],
        },
        'gene': {
            'numerical': [],
            'categorical': [],
            'bool': [],
        },
    }
    percent_top_pattern = re.compile(r'^pct_counts_in_top_(?P<n>\d+)_genes$')
    pct_top = []
    qc_vars_pattern = re.compile(r'^pct_counts_(?P<qc_var>\S+)$')
    qc_vars = []
    for name, vmin, vmax in param:
        if name == 'n_counts' or name == 'index':
            logging.error(
                'Ambiguous parameter name [{0}] given, choose from '
                '"gene:{0}" or "cell:{0}"'.format(name))
            raise ValueError
        pt_match = percent_top_pattern.match(name)
        if pt_match:
            if name not in adata.obs.columns:
                pct_top.append(int(pt_match['n']))
            conditions['cell']['numerical'].append([name, vmin*100, vmax*100])
            continue
        qv_match = qc_vars_pattern.match(name)
        if qv_match and qv_match['qc_var'] in attributes['gene']['bool']:
            if name not in adata.obs.columns:
                qc_vars.append(qv_match['qc_var'])
            conditions['cell']['numerical'].append([name, vmin*100, vmax*100])
            continue
        if name in attributes['cell']['numerical']:
            conditions['cell']['numerical'].append([name, vmin, vmax])
        elif name in attributes['gene']['numerical']:
            conditions['gene']['numerical'].append([name, vmin, vmax])
        else:
            logging.warning('Parameter [{}] undefined, '
                            'dropped from filtering'.format(name))
    for ct in category + subset:
        name = ct[0]
        if not isinstance(ct[1], list):
            fh = ct[1]
            values = fh.read().rstrip().split('\n')
            fh.close()
            ct[1] = values
        if name in attributes['cell']['categorical']:
            conditions['cell']['categorical'].append(ct)
        elif name in attributes['gene']['categorical']:
            conditions['gene']['categorical'].append(ct)
        else:
            logging.warning('Attribute [{}] undefined, '
                            'dropped from filtering'.format(name))
    logging.debug((conditions, qc_vars, pct_top))
    return conditions, qc_vars, sorted(pct_top)


def repr_obj(obj, padding='  ', level=0):
    if isinstance(obj, dict):
        return '\n'.join(['\n'.join([
            padding * level + k + ':', repr_obj(v, level=level+1)
        ]) for k, v in obj.items()])
    elif isinstance(obj, list):
        return '\n'.join([repr_obj(elm, level=level) for elm in obj])
    else:
        return padding * level + repr(obj)


layout_attributes = repr_obj


def repr_attributes(attributes):
    return repr(attributes)


@click.command('filter')
@click.pass_context
@add_options(option_input_obj_and_format)
@add_options(option_output_obj_and_format)
@click.option(
    '--gene-name', '-g',
    help='Name of the variable that contains gene names, '
    'used for flagging mitochondria genes.',
)
@click.option(
    '--list-attr', '-l',
    is_flag=True,
    help='List attributes that can be filtered on',
)
@click.option(
    '--param', '-p',
    type=(str, float, float),
    multiple=True,
    callback=validate_parameter_limits,
    help='Numerical parameters used to filter the data, '
    'in the format of "-p name min max". '
    'Multiple -p entries allowed.',
)
@click.option(
    '--category', '-c',
    type=(str, CommaSeparatedText()),
    multiple=True,
    help='Categorical attributes used to filter the data, '
    'in the format of "-c <name> <values>", '
    'where entries with attribute <name> with value in <values> are kept. '
    'Multiple -c entries allowed.',
)
@click.option(
    '--subset', '-s',
    type=(str, click.File()),
    multiple=True,
    help='Similar to --category in the format of "-s <name> <file>", '
    'but the <file> to be a one-column table that provides the values. '
    'Multiple -s entries allowed.',
)
def filter_cmd(
        ctx,
        input_obj,
        output_obj,
        input_format='anndata',
        output_format='anndata',
        chunk_size=1000,
        show_obj=None,
        gene_name='index',
        list_attr=False,
        param=[],
        category=[],
        subset=[],
):
    """Filter data based on specified conditions.

    \b
    INPUT_OBJ: input file in format specfied by --input-format
    OUTPUT_OBJ: output file in format specfied by --output-format
"""
    logging.debug('--gene-name={}'.format(gene_name))
    logging.debug('--param={}'.format(param))
    logging.debug('--category={}'.format(category))
    logging.debug('--subset={}'.format(subset))

    adata = read_obj(input_obj, input_format=input_format)

    if gene_name:
        try:
            gene_names = getattr(adata.var, gene_name)
            adata.var['mito'] = gene_names.str.startswith('MT-')
        except AttributeError:
            logging.warn(
                'Specified gene column [{}] not found, skip calculating '
                'expression of mitochondria genes'.format(gene_name))

    attributes = get_attributes(adata)
    if list_attr:
        click.echo(layout_attributes(attributes))
        return 0

    conditions, qc_vars, pct_top = get_filter_conditions(
        adata, attributes, param, category, subset)

    sc.pp.filter_cells(adata, min_genes=0)
    sc.pp.filter_cells(adata, min_counts=0)
    sc.pp.filter_genes(adata, min_cells=0)
    sc.pp.filter_genes(adata, min_counts=0)

    if qc_vars or pct_top:
        if not pct_top:
            pct_top = [50]
        sc.pp.calculate_qc_metrics(
            adata, qc_vars=qc_vars, percent_top=pct_top, inplace=True)

    k_cell = np.ones(len(adata.obs)).astype(bool)
    for cond in conditions['cell']['numerical']:
        name, vmin, vmax = cond
        if name.startswith('cell:'):
            name = name[5:]
        attr = getattr(adata.obs, name)
        k_cell = k_cell & (attr >= vmin) & (attr <= vmax)

    for cond in conditions['cell']['categorical']:
        name, values = cond
        attr = getattr(adata.obs, name)
        k_cell = k_cell & attr.isin(values)

    k_gene = np.ones(len(adata.var)).astype(bool)
    for cond in conditions['gene']['numerical']:
        name, vmin, vmax = cond
        if name.startswith('gene:'):
            name = name[5:]
        attr = getattr(adata.var, name)
        k_gene = k_gene & (attr >= vmin) & (attr <= vmax)

    for cond in conditions['gene']['categorical']:
        name, values = cond
        attr = getattr(adata.var, name)
        k_gene = k_gene & attr.isin(values)

    adata = adata[k_cell, :]
    adata = adata[:, k_gene]

    write_obj(
        adata,
        output_obj,
        output_format=output_format,
        chunk_size=chunk_size,
        show_obj=show_obj,
    )
    return 0


@click.command('norm')
@click.pass_context
@add_options(option_input_obj_and_format)
@add_options(option_output_obj_and_format)
@click.option(
    '--overwrite-raw', '-R',
    is_flag=True,
    help='Overwrite existing raw data.',
)
@click.option(
    '--normalise-to', '-t',
    type=float,
    default=10_000,
    show_default='1e4',
    help='Normalise per cell nUMI to this number.',
)
def norm_cmd(
        ctx,
        input_obj,
        output_obj,
        input_format='anndata',
        output_format='anndata',
        chunk_size=1_000,
        show_obj=None,
        overwrite_raw=False,
        normalise_to=10_000,
):
    """Normalise data per cell.

    \b
    INPUT_OBJ: input file in format specfied by --input-format
    OUTPUT_OBJ: output file in format specfied by --output-format
"""
    adata = read_obj(input_obj, input_format=input_format)

    save_raw = True
    if getattr(adata, 'raw'):
        msg = 'Attribute "raw" already exists.'
        if overwrite_raw:
            msg += ' Overwritten because of --overwrite-raw'
        else:
            msg += ' Skip saving raw counts.'
            save_raw = False
        logging.warning(msg)
    if save_raw:
        adata.raw = sc.pp.log1p(adata, copy=True)

    sc.pp.normalize_per_cell(adata, counts_per_cell_after=normalise_to)
    sc.pp.log1p(adata)

    write_obj(
        adata,
        output_obj,
        output_format=output_format,
        chunk_size=chunk_size,
        show_obj=show_obj,
    )
    return 0


@click.command('hvg')
@click.pass_context
@add_options(option_input_obj_and_format)
@add_options(option_output_obj_and_format)
@click.option(
    '--mean-limits', '-m',
    type=(float, float),
    multiple=False,
    callback=validate_limit,
    default=[0.0125, 3],
    show_default=True,
    help='Cutoffs for the mean of expression'
    'in the format of "-m min max".',
)
@click.option(
    '--disp-limits', '-d',
    type=(float, float),
    multiple=False,
    callback=validate_limit,
    default=[0.5, inf],
    show_default=True,
    help='Cutoffs for the dispersion of expression'
    'in the format of "-d min max".',
)
@click.option(
    '--n-bins', '-b',
    type=click.INT,
    default=20,
    show_default=True,
    help='Number of bins for binning the mean gene expression.',
)
@click.option(
    '--n-top', '-t',
    type=click.INT,
    default=20,
    show_default=True,
    help='Number of highly-variable genes to keep.',
)
@click.option(
    '--flavor', '-v',
    type=click.Choice(['seurat', 'cellranger']),
    default='seurat',
    show_default=True,
    help='Choose the flavor for computing normalized dispersion.',
)
@click.option(
    '--subset', '-s',
    is_flag=True,
    default=False,
    help='Inplace subset to highly-variable genes if True, '
    'otherwise only flag highly-variable genes.',
)
def hvg_cmd(
        ctx,
        input_obj,
        output_obj,
        input_format='anndata',
        output_format='anndata',
        chunk_size=1_000,
        show_obj=None,
        mean_limits=[0.0125, 3],
        disp_limits=[0.5, None],
        n_bins=20,
        n_top=None,
        flavor='seurat',
        subset=False,
):
    """Find highly variable genes.

    \b
    INPUT_OBJ: input file in format specfied by --input-format
    OUTPUT_OBJ: output file in format specfied by --output-format
"""
    adata = read_obj(input_obj, input_format=input_format)

    sc.pp.highly_variable_genes(
        adata,
        min_mean=mean_limits[0],
        max_mean=mean_limits[1],
        min_disp=disp_limits[0],
        max_disp=disp_limits[1],
        n_bins=n_bins,
        n_top_genes=n_top,
        flavor=flavor,
        subset=subset,
    )

    write_obj(
        adata,
        output_obj,
        output_format=output_format,
        chunk_size=chunk_size,
        show_obj=show_obj,
    )
    return 0


@click.command('test')
@click.option(
    '--input', '-i',
    type=CommaSeparatedText(int),
    help='comma separated list of integers',
)
def test(input):
    click.echo(input)


cli.add_command(read_cmd)
cli.add_command(filter_cmd)
cli.add_command(norm_cmd)
cli.add_command(hvg_cmd)
cli.add_command(test)


if __name__ == '__main__':
    cli()
